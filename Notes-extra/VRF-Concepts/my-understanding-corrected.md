# My VRF Understanding - Corrected Version

**Purpose**: This document captures my current understanding of VRF oracle systems with corrections and areas to
clarify.

**Legend**:

- ✅ **CORRECT**: I understood this correctly
- ⚠️ **INCOMPLETE**: I had the right idea but missed important details
- ❌ **ERROR**: I misunderstood this - needs correction
- 🔍 **CLARIFY**: Area I need to study more

---

## Part 1: Basic Oracle Flow

### My Understanding:

> Consumer contract calls oracle contract's function (usually `requestRandomWords`), the oracle will return a requestId
> for registering this request (for both consumer and data providers), the event is broadcasted to the network for nodes
> to pick up, after the nodes done processing (VRF or some other calculation), the oracle's `fulfilRandomWords` gets
> called, registering the data with its requestId, and then the oracle can callback at the consumer's predefined
`fulfilRandomWords` with the data so that the consumer can do whatever it wanted to do with the data.

### Assessment: ✅ 85% Correct (⚠️ Missing Critical Step)

**What I got RIGHT**:

- ✅ Consumer calls `requestRandomWords()`
- ✅ RequestId is generated and returned for tracking
- ✅ Event is emitted to the network
- ✅ Nodes detect the event and process it
- ✅ Nodes call `fulfillRandomWords()` with the data
- ✅ Oracle callbacks the consumer's function with the data

**⚠️ What I MISSED** (Critical Security Step):

Between "fulfillRandomWords gets called" and "registering the data", there's a **VERIFICATION STEP**:

```
Nodes call fulfillRandomWords(data, signature proof)
            ↓
    ⚠️ CRYPTOGRAPHIC VERIFICATION HAPPENS HERE!
            ↓
    Contract verifies BLS signature
            ↓
    ┌───────┴───────┐
    │               │
Valid signature  Invalid signature
    │               │
Accept data      Revert transaction
    ↓
Register data with requestId
    ↓
Callback consumer
```

**Why this matters**: Without this step, any node could submit fake data. The signature verification is what makes the
system trustless.

---

### Corrected Complete Flow:

```
Step 1: Request Phase
├─ Consumer calls: oracle.requestRandomWords(numWords)
├─ Oracle stores request: requestMapping[requestId] = {fulfilled: false, ...}
└─ Oracle emits event: RequestSent(requestId, numWords, consumer)

Step 2: Detection Phase
├─ Off-chain nodes monitor blockchain
├─ EventParser detects RequestSent event
└─ Nodes prepare to generate response

Step 3: Generation & Coordination Phase (Off-chain)
├─ Manager generates random data: randomWords = [0x1234..., 0x5678...]
├─ Manager creates message: msgHash = hash(requestId, randomWords, blockNum)
├─ Manager sends to workers: "Sign this msgHash if you agree"
├─ Workers review and sign: σ₁, σ₂, σ₃
└─ Manager aggregates signatures: σ_agg = σ₁ + σ₂ + σ₃

Step 4: Submission Phase (On-chain)
├─ Manager calls: fulfillRandomWords(requestId, randomWords, msgHash, σ_agg, nonSigners)
├─ 🔍 VERIFICATION: Contract verifies BLS signature
│   ├─ Calculate signer APK (subtract non-signers from aggregate pubkey)
│   ├─ Verify pairing: e(σ_agg, G2) == e(H(msgHash), signerAPK)
│   └─ Check threshold: signers >= 2/3 of total
├─ If valid: Register data
│   └─ requestMapping[requestId] = {fulfilled: true, randomWords: randomWords}
└─ If invalid: Revert transaction

Step 5: Callback Phase
└─ Oracle calls: consumer.fulfillRandomWords(requestId, randomWords)
```

---

### 🔍 Areas to CLARIFY:

1. **What happens if verification fails?**
    - Transaction reverts completely
    - No data is stored
    - Gas is wasted by the submitter (economic penalty)

2. **Who pays for gas?**
    - The manager/oracle pays for submission
    - Consumer typically pre-pays or pays upon fulfillment

3. **What if manager never submits?**
    - Request times out
    - Consumer can request again or use fallback
    - This is a liveness issue (not a security issue)

---

## Part 2: BLS Signature Aggregation

### My Understanding:

> BLS basically allows aggregated signature and aggregated verification. All participants have a signing key and a
> public key, all public key aggregates to the ultimate aggregated key, and when a signing happens, participants signs the
> msg to a hash, hashes can also be aggregated to aggregated hash, now, if verification of the aggregated hash is passed
> using aggregated key, then the msg is valid. Now in some cases, not all participant can sign, in this case, the
> aggregated hash is not generated by ALL participants, so the aggregated key should also be regenerated, by aggregating
> all the pub keys of actual participants (though in practice doing subtraction rather than addition, usually fewer people
> do not sign, hence sub is easier).

### Assessment: ⚠️ 60% Correct (❌ Critical Error on Hash Aggregation!)

**What I got RIGHT**:

- ✅ BLS allows signature aggregation
- ✅ BLS allows aggregated verification (one check for all)
- ✅ Participants have signing key (private) and public key (public)
- ✅ Public keys aggregate to form aggregated public key (APK)
- ✅ When not all sign, regenerate aggregated key
- ✅ Use subtraction (remove non-signers) rather than addition (for efficiency)

**❌ CRITICAL ERROR**:

> "participants signs the msg to a hash, **hashes can also be aggregated to aggregated hash**"

**THIS IS WRONG!** Hashes do NOT aggregate. Let me correct:

---

### ❌ ERROR: What Gets Aggregated

**What I said** (WRONG):

```
❌ Each participant signs msg to create a hash
❌ Hashes aggregate to aggregated hash
❌ Verify aggregated hash with aggregated key
```

**What ACTUALLY happens** (CORRECT):

```
✅ There is ONE message hash (same for everyone)
✅ Each participant signs that SAME hash to create a SIGNATURE
✅ SIGNATURES aggregate (not hashes!)
✅ Verify aggregated SIGNATURE against the single msgHash
```

---

### Corrected BLS Flow:

```
Setup Phase:
├─ Worker 1: Private key sk₁, Public key PK₁
├─ Worker 2: Private key sk₂, Public key PK₂
├─ Worker 3: Private key sk₃, Public key PK₃
└─ Aggregate Public Key (on-chain): APK = PK₁ + PK₂ + PK₃

Signing Phase:
├─ Input message: msg = "requestId=123, randomWords=[0x1234, 0x5678]"
├─ Hash message (SAME for everyone): msgHash = keccak256(msg)
│
├─ Worker 1 signs msgHash:
│   └─ σ₁ = BLS_Sign(msgHash, sk₁)  ← Creates SIGNATURE (not another hash!)
│
├─ Worker 2 signs msgHash:
│   └─ σ₂ = BLS_Sign(msgHash, sk₂)  ← Different signature (different key)
│
└─ Worker 3 signs msgHash:
    └─ σ₃ = BLS_Sign(msgHash, sk₃)  ← Different signature (different key)

    NOTE: All three signed THE SAME msgHash!
          Each produced a DIFFERENT signature!

Aggregation Phase (Off-chain):
└─ Aggregate SIGNATURES (NOT hashes):
    σ_aggregate = σ₁ + σ₂ + σ₃  ← Elliptic curve point addition

Verification Phase (On-chain):
├─ Input: σ_aggregate, msgHash (the original hash), APK
├─ Verify using pairing check:
│   e(σ_aggregate, G2) == e(H(msgHash), APK)
│
└─ If equation holds: ✅ All signatures valid
    If equation fails: ❌ Invalid signature
```

---

### 🔍 Key Distinction to CLARIFY:

| Concept                | What I Thought (❌)                              | What's Correct (✅)                                       |
|------------------------|-------------------------------------------------|----------------------------------------------------------|
| **Message**            | Different for each signer?                      | SAME for all signers                                     |
| **Hash (msgHash)**     | Each produces different hash? Hashes aggregate? | ONE hash, same for all. Does NOT aggregate.              |
| **Signature**          | Not mentioned?                                  | Each produces DIFFERENT signature. SIGNATURES aggregate! |
| **What aggregates?**   | Hashes                                          | Signatures (σ₁ + σ₂ + σ₃)                                |
| **Verification input** | Aggregated hash                                 | Original msgHash + Aggregated signature                  |

---

### Concrete Example:

```
Scenario: 3 workers sign the same message

Message:
msg = "Send 100 ETH to Alice"
msgHash = keccak256(msg) = 0xABCD1234...  ← SAME for all 3 workers

Worker 1:
├─ Has: sk₁ (private key)
├─ Signs msgHash: σ₁ = Sign(0xABCD1234..., sk₁)
└─ Result: σ₁ = (X₁, Y₁)  ← Elliptic curve point

Worker 2:
├─ Has: sk₂ (private key)
├─ Signs msgHash: σ₂ = Sign(0xABCD1234..., sk₂)
└─ Result: σ₂ = (X₂, Y₂)  ← Different point!

Worker 3:
├─ Has: sk₃ (private key)
├─ Signs msgHash: σ₃ = Sign(0xABCD1234..., sk₃)
└─ Result: σ₃ = (X₃, Y₃)  ← Different point!

Aggregation:
├─ σ_agg = σ₁ + σ₂ + σ₃  ← Point addition on elliptic curve
└─ σ_agg = (X_agg, Y_agg)  ← Single aggregated point

On-chain submission:
├─ Submit: msgHash = 0xABCD1234... (the ORIGINAL hash)
├─ Submit: σ_agg = (X_agg, Y_agg)  (the AGGREGATED signature)
└─ Contract verifies: Does σ_agg prove all three signed msgHash?
```

**Key insight**:

- The msgHash (0xABCD1234...) is transmitted once, unchanged
- The signatures (σ₁, σ₂, σ₃) are combined into σ_agg
- Verification checks: "Does σ_agg prove that holders of sk₁, sk₂, sk₃ all signed THIS SPECIFIC msgHash?"

---

### ✅ What I Got Right (Non-Signer Handling):

> "in some cases, not all participant can sign, the aggregated key should be regenerated, by aggregating all the pub
> keys of actual participants (though in practice doing subtraction)"

**This is CORRECT!** Let me expand:

```
Scenario: 3 registered workers, but Worker 3 is offline

Registered (on-chain):
APK = PK₁ + PK₂ + PK₃

Only Worker 1 and 2 sign:
├─ σ₁ = Sign(msgHash, sk₁)
└─ σ₂ = Sign(msgHash, sk₂)

Aggregation:
├─ σ_agg = σ₁ + σ₂  ← Only 2 signatures
├─ σ_agg represents ONLY Worker 1 and 2
└─ To verify, need APK of ONLY signers

Signer APK calculation (on-chain):
├─ Start with full APK: APK_all = PK₁ + PK₂ + PK₃
├─ Remove non-signer: APK_signers = APK_all - PK₃
└─ Now: APK_signers = PK₁ + PK₂  ← Matches the signers!

Verification:
e(σ_agg, G2) == e(H(msgHash), APK_signers)
      ↑                            ↑
  σ₁ + σ₂                      PK₁ + PK₂

✅ Verification passes because signature and pubkey match!
```

**Why subtraction is efficient**:

- Usually most workers sign (e.g., 8 out of 10)
- Cheaper to subtract 2 non-signers: `APK - PK₉ - PK₁₀`
- Than to add 8 signers: `PK₁ + PK₂ + ... + PK₈`

**Code reference**: `BLSApkRegistry.sol:128-138`

```solidity
signerApk = currentApk;  // Start with all
for (nonSigner in nonSignerPubKeys) {
signerApk = signerApk.minus(nonSigner);  // Subtract non-signers
}
```

---

## Part 3: BLS in the Oracle Process

### My Understanding:

> There's a manager that generates the expected data, and the signers are there to provide cryptographic proof that they
> agree with the data generated.

### Assessment: ✅ 90% Correct

**What I got RIGHT**:

- ✅ Manager generates the data (randomWords)
- ✅ Signers provide cryptographic proof
- ✅ The proof shows they agree with the data

**⚠️ What to ADD** (for complete picture):

---

### Complete Oracle Process with BLS:

```
┌─────────────────────────────────────────────────────────────────┐
│                  PHASE 1: EVENT DETECTION                       │
├─────────────────────────────────────────────────────────────────┤
│ Blockchain emits: RequestSent(requestId=123, numWords=2)       │
│         ↓                                                        │
│ All nodes detect event (Manager + Workers)                      │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│              PHASE 2: DATA GENERATION (Off-chain)               │
├─────────────────────────────────────────────────────────────────┤
│ Manager Node:                                                   │
│ ├─ Reads requestId=123                                          │
│ ├─ Generates random data: randomWords = [0x1234..., 0x5678...]  │
│ └─ Creates message:                                             │
│     msg = {requestId: 123, randomWords: [...], blockNum: 1000}  │
│     msgHash = keccak256(msg)                                    │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│            PHASE 3: SIGNATURE COORDINATION (Off-chain)          │
├─────────────────────────────────────────────────────────────────┤
│ Manager sends via WebSocket to all workers:                     │
│   {                                                             │
│     requestId: 123,                                             │
│     randomWords: [0x1234..., 0x5678...],                        │
│     msgHash: 0xABCD...,                                         │
│     request: "Please sign this msgHash if you agree"           │
│   }                                                             │
│                                                                 │
│ Worker 1:                                                       │
│ ├─ Receives data                                                │
│ ├─ (Optional) Validates: hash matches, data looks reasonable   │
│ ├─ Decision: AGREE                                              │
│ ├─ Signs: σ₁ = BLS_Sign(msgHash, sk₁)                          │
│ └─ Sends back to Manager: {signature: σ₁, vote: YES}           │
│                                                                 │
│ Worker 2:                                                       │
│ ├─ Receives data                                                │
│ ├─ Decision: AGREE                                              │
│ ├─ Signs: σ₂ = BLS_Sign(msgHash, sk₂)                          │
│ └─ Sends back: {signature: σ₂, vote: YES}                      │
│                                                                 │
│ Worker 3:                                                       │
│ ├─ Receives data                                                │
│ ├─ Decision: OFFLINE / DISAGREE                                 │
│ └─ Sends back: {signature: null, vote: NO, pubkey: PK₃}        │
│                                                                 │
│ Manager receives responses:                                     │
│ ├─ Signatures: [σ₁, σ₂]                                         │
│ ├─ Non-signers: [PK₃]                                           │
│ ├─ Check threshold: 2/3 signed ✅                               │
│ └─ Aggregate: σ_agg = σ₁ + σ₂                                   │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│              PHASE 4: ON-CHAIN SUBMISSION                       │
├─────────────────────────────────────────────────────────────────┤
│ Manager submits transaction:                                    │
│   fulfillRandomWords(                                           │
│     requestId: 123,                                             │
│     randomWords: [0x1234..., 0x5678...],  ← The actual data    │
│     msgHash: 0xABCD...,                    ← What was signed    │
│     blockNum: 1000,                                             │
│     proof: {                                                    │
│       sigma: σ_agg,           ← Aggregated signature           │
│       apkG2: APK_G2,          ← Aggregate public key           │
│       nonSigners: [PK₃],      ← Who didn't sign                │
│       stakes: {...}                                             │
│     }                                                           │
│   )                                                             │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│              PHASE 5: ON-CHAIN VERIFICATION                     │
├─────────────────────────────────────────────────────────────────┤
│ Smart Contract (VRFManager.fulfillRandomWords):                │
│                                                                 │
│ Step 1: Verify signature                                       │
│   blsRegistry.checkSignatures(msgHash, blockNum, proof)        │
│                                                                 │
│ ┌───────────────────────────────────────────────────────┐     │
│ │  BLSApkRegistry.checkSignatures():                    │     │
│ │                                                        │     │
│ │  1. Calculate signer APK:                             │     │
│ │     signerAPK = currentAPK - PK₃                      │     │
│ │     (Remove non-signers from aggregate pubkey)        │     │
│ │                                                        │     │
│ │  2. Verify pairing equation:                          │     │
│ │     e(σ_agg + γ·signerAPK, -G2) *                     │     │
│ │     e(H(msgHash) + γ·G1, APK_G2) == 1                 │     │
│ │                                                        │     │
│ │     This proves: σ_agg is valid signature of msgHash  │     │
│ │                  by holders of sk₁ and sk₂            │     │
│ │                                                        │     │
│ │  3. Check threshold:                                  │     │
│ │     signers = 2, total = 3                            │     │
│ │     2/3 >= 0.67 ✅ Threshold met                      │     │
│ │                                                        │     │
│ │  4. Return: ✅ Valid                                  │     │
│ └───────────────────────────────────────────────────────┘     │
│                                                                 │
│ Step 2: Store data (only if verification passed)               │
│   requestMapping[123] = {                                      │
│     fulfilled: true,                                           │
│     randomWords: [0x1234..., 0x5678...]                        │
│   }                                                            │
│                                                                 │
│ Step 3: Emit event                                             │
│   emit FillRandomWords(123, [0x1234..., 0x5678...])           │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                  PHASE 6: CONSUMER CALLBACK                     │
├─────────────────────────────────────────────────────────────────┤
│ Oracle calls consumer's callback:                              │
│   consumer.fulfillRandomWords(                                 │
│     requestId: 123,                                            │
│     randomWords: [0x1234..., 0x5678...]                        │
│   )                                                            │
│                                                                 │
│ Consumer uses the random data for its logic                    │
└─────────────────────────────────────────────────────────────────┘
```

---

### 🔍 Key Points to CLARIFY:

#### 1. What does "agree with the data" mean?

**My understanding**: Signers cryptographically prove they agree

**More detail**:

- ✅ **Minimum**: Signer is online and willing to participate
- ⚠️ **Validation** (optional): Signer checks data looks reasonable
- ⚠️ **Honesty**: Signer confirms they witnessed/validated the generation

**What the signature proves ON-CHAIN**:

- ✅ This specific data (randomWords)
- ✅ Was signed by these specific signers (who have the secret keys)
- ✅ At this specific time (blockNumber)

**What the signature does NOT prove**:

- ❌ The data is truly random
- ❌ The data wasn't cherry-picked by manager
- ❌ The generation process was honest

**Security relies on**:

1. Cryptography: Can't forge signatures (math guarantees)
2. Threshold: 2/3 must collude to cheat (economic assumption)
3. Reputation: Signers stake reputation on honesty (social layer)

---

#### 2. Why do we need multiple signers if manager generates the data?

**Good question!** This confused me at first.

**Without multiple signers** (single oracle):

```
Manager generates data → Signs alone → Submits
Problem: Manager could generate 1000 times, pick best result
No accountability, pure trust
```

**With multiple signers** (DappLink model):

```
Manager generates data → Multiple independent parties must agree → Submit
Benefits:
- ✅ M-of-N must collude to cheat (harder)
- ✅ If 1 signer refuses, others know something's wrong
- ✅ Distributed trust (not single point)
- ✅ Economic security (all signers stake reputation)
```

**Analogy**:

- **Single signer**: One person writes a check, signs it themselves
- **Multiple signers**: One person writes check, but 2-of-3 co-signers must approve

The data generation may be centralized, but the **attestation** is decentralized.

---

#### 3. What's the difference between this and true threshold VRF?

**DappLink Model** (what I learned):

```
Generation: Centralized (manager)
Attestation: Decentralized (2/3 signers)
Security: Consensus on externally-generated data
```

**True Threshold VRF** (advanced):

```
Generation: Decentralized (all participants contribute entropy)
Attestation: Part of the VRF proof
Security: Consensus-generated data

Each participant:
1. Generates VRF share: vrf₁, vrf₂, vrf₃
2. Combines shares: final_vrf = Combine(vrf₁, vrf₂, vrf₃)
3. Each share is verifiable on-chain

Result: No single party generated the randomness
```

DappLink is simpler but less decentralized than threshold VRF.

---

## Summary: My Learning Journey

### What I Understood Correctly:

1. ✅ High-level oracle flow (request → detect → generate → fulfill → callback)
2. ✅ BLS allows signature aggregation
3. ✅ Public keys aggregate to form APK
4. ✅ Non-signers are handled by subtraction from APK
5. ✅ Manager generates data, workers attest

### Critical Errors I Made:

1. ❌ **Thought hashes aggregate** → Actually SIGNATURES aggregate
2. ⚠️ **Missed verification step** → This is the core security mechanism

### Concepts I Need to Clarify:

1. 🔍 BLS pairing math (how e(σ, G2) == e(H(m), PK) works)
2. 🔍 How elliptic curve point addition works for aggregation
3. 🔍 What happens if verification fails (transaction reverts)
4. 🔍 Difference between this model and true threshold VRF
5. 🔍 Security assumptions (why 2/3 threshold, what if all collude?)

---

## Next Steps for Learning

### To solidify BLS understanding:

1. **Draw it out**: Manually trace one signing + verification example
2. **Code it**: Try OpenZeppelin ECDSA first (simpler), then explore BLS
3. **Math**: Learn basic elliptic curve operations (don't need to be expert)

### To understand verification:

1. Read `BLSApkRegistry.sol` line by line
2. Understand what `pairing` function does (conceptually)
3. See why invalid signatures would fail the pairing check

### For the homework:

1. Start with ECDSA (simpler)
2. Implement single oracle (no aggregation)
3. Understand minimal proxy and CREATE2 first
4. BLS is advanced - optional

---

## Key Takeaways

**The BIG picture**:

1. Oracle systems need **proof** that data is honest
2. **BLS signatures** provide this proof through aggregation
3. **Multiple signers** create threshold security (2/3 must collude)
4. **Verification happens on-chain** (trustless)
5. **Coordination happens off-chain** (gas efficient)

**The CRITICAL correction**:

- ❌ NOT: "Hashes aggregate"
- ✅ YES: "Signatures aggregate, proving multiple parties signed THE SAME hash"

**The mental model**:

```
Think of it like a petition:
- Message: "We approve this randomness"  ← ONE message
- Signatures: Alice, Bob, Charlie sign   ← MULTIPLE signatures
- Aggregate: Combine all signatures      ← ONE proof of all signatures
- Verify: Check combined signature proves all signed the petition
```

Same message, multiple signatures, combined into one proof!

---

## Reference Code Locations

For my future study:

**Smart Contracts** (DappLink VRF):

- Main flow: `DappLinkVRFManager.sol:37-54`
- Signature verification: `BLSApkRegistry.sol:124-149`
- Pairing check: `BLSApkRegistry.sol:156-176`
- Non-signer handling: `BLSApkRegistry.sol:128-138`

**Off-chain Service** (vrf-node):

- Manager coordination: `manager/manager.go:188-269`
- Signature collection: `manager/sign.go:18-129`
- Aggregation: `manager/sign.go:160-181`
- Threshold check: `manager/sign.go:117-119`

**My Notes**:

- VRF basics: `Notes-extra/VRF-Concepts/cryptographic-verification.md`
- BLS deep dive: `Notes-extra/VRF-Concepts/dapplink-bls-implementation.md`
- Coordination model: `Notes-extra/VRF-Concepts/dapplink-coordination-model.md`
- This document: `Notes-extra/VRF-Concepts/my-understanding-corrected.md`

---

*Generated: 2025-10-23*
*Status: Corrected version of my initial understanding*
*Review: Focus on the ❌ ERROR sections and 🔍 CLARIFY items*
